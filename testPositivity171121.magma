/*
    I don't know if these are necessary. I suspect not, but it might be the
    magic of typecasting.
*/
QQ := RationalField();
P<q> := PowerSeriesRing(QQ);
ZZ := IntegerRing();
R<q> := PowerSeriesRing(ZZ);


getFileName := function(level, weight, prec)
  fileName := "L";
  fileName cat:= IntegerToString(level);
  fileName cat:= "W";
  fileName cat:= IntegerToString(weight);
  fileName cat:= "P";
  fileName cat:= IntegerToString(prec);
  return fileName;
end function;



/*
  Returns the coefficients of the q-expansion at infinity padded
  to the full precision of the q-expansion.
*/
getCoefficientsToPrecision := function(series, precision)
  Coeffs, startpadding, d := Coefficients(series);
  Coeffs := [ 0 : x in [1..startpadding] ] cat Coeffs;
  endpadding := AbsolutePrecision(series) - ( #Coeffs );
  Coeffs cat:= [ 0 : x in [1..endpadding] ];
  //Coeffs;
  return Coeffs;
end function;



/* Given the sequence [a0, a1, ...], returns a sequence of the
   same length [a_0, 0, ..., 0, a_1, ...] such that each run 
   contains (expansionFactor - 1) zeros. */
ExpandAtPrecision := function(sequence, expansionFactor, weight)
  prec := # sequence;
  holder := [Rationals() | 0 : x in [1..prec]];
  j := 1;
  while expansionFactor * (j - 1) + 1 le prec do
    holder[expansionFactor * (j - 1) + 1] := sequence[j];
    j +:= 1;
  end while;
  return holder;
end function; 



/* Given the sequence [a0, a1, ...], returns a sequence of the
   same length [a_0, 0, ..., 0, (expansionFactor)^((weight - 1)/2) a_1, ...] 
   such that each run contains (expansionFactor - 1) zeros.  */
ExpandAtPrecision2 := function(sequence, expansionFactor, weight)
  prec := # sequence;
  multiplier := (expansionFactor)^((weight - 1)/2);
  holder := [RealField() | 0 : x in [1..prec]];
  j := 1;
  while expansionFactor * (j - 1) + 1 le prec do
    holder[expansionFactor * (j - 1) + 1] := RealField()!(sequence[j]) * multiplier;
    j +:= 1;
  end while;
  return holder;
end function; 



/* Given the sequence [a0, a1, ...], returns a sequence of the
   same length [a_0, 0, ..., 0, (expansionFactor)^((weight)/2) a_1, ...] 
   such that each run contains (expansionFactor - 1) zeros. */
ExpandAtPrecisionWeak := function(sequence, expansionFactor, weight)
  //sequence;
  prec := # sequence;
  multiplier := (expansionFactor)^(Integers()!(weight/2));
  holder := [Rationals() | 0 : x in [1..prec]];
  j := 1;
  while expansionFactor * (j - 1) + 1 le prec do
    holder[expansionFactor * (j - 1) + 1] := (sequence[j]) * multiplier;
    j +:= 1;
  end while;
  return holder;
end function; 



/* Given the sequence [a0, a1, ...], returns a sequence of the
   same length [a_0, 0, ..., 0, (expansionFactor)^((weight)/2) a_1, ...] 
   such that each run contains (expansionFactor - 1) zeros. Applied to the 
   coefficients of a cuspidal newform (which therefore obeys the Deligne 
   bounds), this gives the coefficients of an oldform (of higher level)
   which also obeys the same cusp form bound as the original sequence. */
ExpandAtPrecisionWeakTest := function(sequence, expansionFactor, weight)
  // Get precision from sequence length.
  prec := # sequence;

  // The multiplier is a scale factor to use Deligne bounds as well as possible.
  multiplier := (expansionFactor)^(Integers()!(weight/2));

  // Prepare output sequence of the correct type, and pre-fill zeros.
  holder := [FieldOfFractions(Parent(sequence[1]))| 0 : x in [1..prec]];

  // Loop over the sequence, `spreading it out' and rescaling to get 
  // the coefficients of some oldform.
  j := 1;
  while expansionFactor * (j - 1) + 1 le prec do
    holder[expansionFactor * (j - 1) + 1] := (sequence[j]) * multiplier;
    j +:= 1;
  end while;
  return holder;
end function; 



/* 
  Computes a basis for the space of cusp forms of level and weight 
  consisting of newforms (new eigenforms) and oldforms (forms coming from
  newforms of lower level.) 
  Returns: (3 outputs)
      Sequences containing the q-expansions for a basis of cusp forms as 
          above (with coefficients in possibly different number fields.)
      List of `expansion factors' denoting how much the basis elements
          have been `spread out' relative to the corresponding newform 
          (of possibly lower level.) Collectively, these can be used to 
          recover the original level of the oldforms.
      Minimal simultaneous field of definition of all forms in the basis.
*/
DumbGetCuspidalNewformBasis := function(level, weight, prec)
  /* 
     We don't use a sequence here, since Magma may view the different 
     basis elements as defined over different number fields.
  */
  basis := [* *];
  
  /*
     expansions keeps track of data relating to how each basis element 
     was formed. In particular, it holds the information of how `spread out'
     the basis element is relative to the corresponding newform (of possibly
     lower level.) 
  */
  expansions := [];

  /*
     fieldOfDef tracks the Number Field over which all of the forms are defined.
     In the easiest case, it is just the rationals, but frequently requires 
     higher degree extensions at fairly small weight and level.
  */
  fieldOfDef := Rationals();

  // Loop over all levels which could be the original source of oldforms.
  for d in Divisors(level) do
    
    /*
        Compute the newforms of Level = d, Weight = weight. Note that if two 
        newforms are conjugate over the rationals, this only gives one 
        representative of the conjugacy class.
    */   
    C := CuspForms(d, weight);
    SetPrecision(C, prec);
    newforms := Newforms(C);

    /*
         Not sure why this if statement is here... probably legacy from an
         earlier version of the code.
    */
    if #newforms gt 0 then
      for fWrapped in newforms do
        // We want to work directly with the coefficients of the q-expansions.
        f := qExpansion(fWrapped[1]);
        seq := getCoefficientsToPrecision(f, prec);

        /*
             Find field of definition of this form so we can find its conjugates
             and update the field of definition of the basis.
        */
        localFieldOfDef := FieldOfFractions(Parent(seq[1]));
        fieldOfDef := Compositum(fieldOfDef, localFieldOfDef);

        /*
             Now we loop over conjugates of the form, to make sure we are 
             going over all newforms.
        */
        for map in Automorphisms(localFieldOfDef) do
          seq2 := [map(elt) : elt in seq];
          
          /*     
               Get all of the oldforms corresponding to our current newform,
               and keep track of how much they were `spread out' relative
               to the original form. 
          */
          for e in Divisors(Integers()!(level/d)) do
            Append(~basis, ExpandAtPrecisionWeakTest(seq2, e, weight));
            Append(~expansions, e);
          end for;
        end for;
      end for;
    end if;
  end for;
  return basis, expansions, fieldOfDef;
end function;



/* 
  Computes a basis for the space of modular forms of level and weight 
  consisting of newforms (new eigenforms) and oldforms (forms coming from
  newforms of lower level) and Eisenstein series. The Eisenstein series 
  come last.
  Returns: (3 outputs)
      Sequences containing the q-expansions for a basis of modular forms as 
          above (with coefficients in possibly different number fields.)
      List of `expansion factors' denoting how much the basis elements
          have been `spread out' relative to the corresponding newform 
          (of possibly lower level.) Collectively, these can be used to 
          recover the original level of the oldforms.
      Minimal simultaneous field of definition of all forms in the basis.
  Assumes: 
      Coefficients of the Eisenstein series are rational (cusp forms
      need not have rational coefficients).
*/
DumbGetNewformBasis := function(level, weight, prec)
  // Get the portion of the basis consisting of cusp forms.
  basis, cExpansions, fieldOfDef := DumbGetCuspidalNewformBasis(level, weight, prec); 

  /*
       Get sequences of coefficients of the Eisenstein series.
  */
  M := ModularForms(level, weight);
  ESeries := EisensteinSeries(M);
  E := [P!qExpansion(e,prec): e in ESeries];
  basis2 := [*getCoefficientsToPrecision(f,prec) : f in E*];
  
  // TODO: Update fieldOfDef here to account for basis2.

  // Put them together.
  return basis cat basis2, cExpansions, fieldOfDef;
  /* Is there a good way to store the Eisenstein data (including the characters?) */
end function;

/* 
   Returns a basis as a sequence of sequences of coefficients.
   This is a version of DumbGetNewformBasis that is supposed to read things
   from a file. But, it needs to be significantly more intelligent and to keep
   track of a lot more data if it is going to be able to handle modular forms
   with coefficients in number fields (at least the name of the generator and
   a minimal polynomial). For now, I recommend repeating computation and using
   the DumbGetNewformBasis.
*/
GetNewformBasis := function(level, weight, prec: write := true)
  filename := "Bases/";
  filename cat:= getFileName(level,weight,prec);
  filenameExp := filename cat "NewCuspExpansions.txt";
  filename cat:= "New.txt";
  System("touch " cat filename);
  contents := Read(filename);
  System("touch " cat filenameExp);
  contentsExp := Read(filenameExp);

  if (contents eq "") or (contentsExp eq "") then
    basis, cExp := DumbGetNewformBasis(level, weight, prec);
    if write then
      System("rm " cat filename);
      System("rm " cat filenameExp);
      Write(filename, basis);
      Write(filenameExp, cExp);
    else
      if contents eq "" then
        System("rm " cat filename);
      end if;
      if contentsExp eq "" then
        System("rm " cat filenameExp);
      end if;
    end if;
  else
    basis := eval(contents);
    cExp := eval(contentsExp);
  end if;
  return basis, cExp;
end function;



/* 
  Assumes all Eisenstein series in play have real coefficients.
  Returns a value lb so that the coefficient of n of the Eisenstein 
  part is at least lb * n^(k-1), where k is the weight.
  This version hasn't been thought through sufficiently yet. Also, it seems
  to be worse than the other version in practice, so I haven't put much time
  into making it work.
*/
EisensteinLowerBoundAltPossiblyWrong := function(coords, level, weight)
  M := ModularForms(level, weight);
  ESeries := EisensteinSeries(M);
  lb := 0;
  for d in [1..level] do
    sum := 0;
    for e in [1..#coords] do
      t := EisensteinData(ESeries[e])[3];
      chi := EisensteinData(ESeries[e])[1];
      if d mod t eq 0 then
        if (chi(d) * coords[e]) gt 0 then 
          multiplier := (1/t)^(weight - 1);
        else
          multiplier := 0;
          Divs := Divisors(IntegerRing()!(d/t));
          for dv in Divs do
            multiplier +:= (dv/d)^(weight - 1);
          end for;
          //t;
        end if;
        sum +:= (EisensteinData(ESeries[e])[1](d) * coords[e]) * multiplier;
      end if;
    end for;
    if d eq 1 then 
      lb := sum;
    else
      lb := Minimum(lb, sum);
    end if;
    //sum;
  end for;
  return lb;
end function;

/* 
  Assumes all Eisenstein series in play have real coefficients.
  Returns a value lb so that the coefficient of n of the Eisenstein 
  part is at least lb * sigma_{k-1}(n) >= lb * n^(k-1), where k is the weight.
  The key observation used is that if t divides n, then
    sigma_{k-1}(n)/t^{k-1} >= sigma_{k-1}(n/t) >= sigma_{k-1}(n)/sigma_{k-1}(t).
  We combine this with the explicit formula for the coefficients of Eisenstein
  series to get a bound. More refined estimates are possible, but of little value.
  Assumptions:
       All Eisenstein Series have rational coefficients.
       Equivalently, the level is not divisible by m^2 unless m divides 24.
       This assumption could be removed in principle, with a substantial rewrite
       impacting both the coefficient bounds and positivity checking.
*/
EisensteinLowerBound := function(coords, level, weight)
  //    Get the Eisenstein Series.
  M := ModularForms(level, weight);
  ESeries := EisensteinSeries(M);

  //   Initialize the lower bound to any value (so we can set it conditionally.)
  lb := 0;

  /*
       We will get a different bound for each congruence class modulo the level. 
       We can bound all of these at once, since all values of t, and conductors 
       of characters chi divide the level.
  */
  for d in [1..level] do
    sum := 0;
    for e in [1..#coords] do
      /*
          t captures how `spread out' the Eisenstein series is.
          chi determines which coefficients are positive or negative (or 0).
          The coefficient of q^(nt) is chi(n) * sigma_{k-1}(n).
      */
      t := EisensteinData(ESeries[e])[3];      
      chi := EisensteinData(ESeries[e])[1];
      if d mod t eq 0 then
        /*
             Test whether the contribution of the e-part to the d (mod level)
             coefficients of the form is positive or negative. This is determined
             by whether the Eisenstein Series has positive or negative 
             coefficients in the d (mod level) places, and whether the form has
             a positive or negative coordinate at e in the Eisenstein basis. 
             If < 0, use:
                 -sigma_{k-1}(d/t) >= -sigma_{k-1}(d)/t^{k-1}.
             If > 0, use:
                 sigma_{k-1}(d/t) <= sigma_{k-1}(d)/sigma_{k-1}(t).
             More refined estimates are possible, but add little value.
        */
        if (chi(Integers()!(d/t)) * coords[e]) lt 0 then 
          multiplier := (t)^(weight - 1);
        else
          multiplier := 0;
          Divs := Divisors(IntegerRing()!(t));
          for dv in Divs do
            multiplier +:= (dv)^(weight - 1);
          end for;
        end if;
        /*
              We need to add up the (lower bound of the) contribution 
              from all of the forms. If d is not a multiple of t, then
              we know the contribution from e is zero, so the loop is correct.
        */
        sum +:= (EisensteinData(ESeries[e])[1](Integers()!(d/t)) * coords[e]) / multiplier;
      end if;
    end for;
    // We preset to 0, so reset on the first element rather than taking a min.
    if d eq 1 then 
      lb := sum;
    else
      lb := Minimum(lb, sum);
    end if;
  end for;
  // Return the worst lower bound we find.
  return lb;
end function;



/* 
  Returns a value ub so that the coefficient of n of the cuspidal 
  part is at most 2 * ub * n^(k/2), where k is the weight.
  This should work in full generality, although it may get slow if the 
  coordinates are defined over a large number field.
  This bound is based on the Deligne bounds for cuspidal newforms. If you wish
  to use some other bound, you will need to update the normalizations of the 
  oldforms in DumbGetNewformBasis, but this code should be just fine.
*/
CuspUpperBound := function(coords)
  /*
       Some Magma fussiness to get around the fact that Rationals() aren't a
       number field in Magma. Changing field is one option. You could also just
       check types and write separate code for the Rationals() case. This would
       probably be slightly faster, but we're not doing any linear algebra here,
       so it's probably insignificant.
  */
  field := Parent(coords[1]);
  field := Compositum(QNF(), field);
  
  /*
      We normalized our oldforms so they have the same upper bound as the 
      normalized new forms. So we just need to add up the absolute values
      of the coordinates to get a bound on the magnitude.
  */
  sum := 0;
  for x in coords do
    sum +:= AbsoluteValues(field!x)[1];
  end for;
  return sum;
end function;

/* 
   Some code to take a sequence f and find its coordinates in some basis.
   N.B. Successful operation of this step is an excellent check that we 
   computed our new/oldform basis correctly. We would have to get really 
   lucky to get the right value otherwise.

   This doesn't really need level, weight, or prec as inputs. fieldOfDef 
   could also be removed at the cost of duplicating some computations.
   Returns:
        A list of coefficients of f in fieldOfDef for the basis.
   Assumptions:
        All of the coefficients of f and of the elements of basis can be
        coerced into fieldOfDef.
        f lies in the span of the elements of basis.
*/
GetFullCoordsInBasis := function(basis, f, level, weight, prec, fieldOfDef)
  V := VectorSpace(fieldOfDef, prec);
  W := VectorSpaceWithBasis([V!v : v in basis]);
  return Coordinates(W, V!f);
end function;

/*
    Inputs: 
        basis - A basis for a space of modular forms which is the concatenation of
                a basis of the space of cusp forms and a basis for the Eisenstein
                subspace.
        f - The sequence of coefficients of the q-expansion of a modular form,
            assumed to be in the span of basis.
        level - the level of f and the basis.
        weight - the weight of f and the basis.
        prec - the number of coefficients specified in f and the basis elements.
        fieldOfDef - a minimal field of definition of all of the forms 
                     represented in basis and f. 
     Outputs:
        two sequences of coordinates.
        first the sequence of coordinates for the cuspidal part in terms of 
        the cuspidal part of the basis.
        second the sequence of coordinates for the Eisenstein part in terms of 
        the Eisenstein part of the basis.
     Assumes: 
        Everything follows the instructions in inputs.
        The coefficients of the Eisenstein part are rational.
*/
GetSplitCoordsInBasis := function(basis, f, level, weight, prec, fieldOfDef)
  coords := GetFullCoordsInBasis(basis, f, level, weight, prec, fieldOfDef);
  
  // The first cDim coordinates are cuspidal, the rest are Eisenstein.
  cDim := Dimension(CuspForms(level, weight));
  mDim := Dimension(ModularForms(level, weight));
  bCoords := coords[1..cDim];
  eCoords := coords[(cDim+1)..mDim];
  eCoords := [Rationals()! e : e in eCoords];
  return bCoords, eCoords;
end function;

/*
      Input:
          f - The sequence of coefficients of a modular form.
          level - the level of the form.
          weight - the weight of the form.
          prec - the number of coefficients of f given.
      Output:
          An integer M such that to check that all of the coefficients of the
               modular form f are non-negative, it suffices to check that the
               first M coefficients are non-negative (based on Deligne bounds 
               for newforms and explicit formulas for Eisenstein series.)
      Assumptions:
          All Eisenstein series at level and weight have rational coefficients.
          f has real coefficients.
          Probably other things...
*/
NumberOfCoefficientsForPositivityCheck := function(f, level, weight, prec)
  newBasis, blah, fieldOfDef := DumbGetNewformBasis(level, weight, prec);
  bCoords, eCoords := GetSplitCoordsInBasis(newBasis, f, level, weight, prec, fieldOfDef);
  eCoords := [Rationals()!e : e in eCoords];
  En := EisensteinLowerBound(eCoords, level, weight);
  //RealField()!En;
  Cn := CuspUpperBound(bCoords);
  //RealField()!Cn;
  /*
      At this point, if An is the coefficient of n, the triangle inequality 
      implies that:
                An >= En * n^{k-1} - 2 * Cn * n^{k/2}.
      The right-hand side is positive when 
                n^{(weight/2) - 1} >= 2 * Cn / En.
      So, to confirm positivity, it will suffice to check coefficients up to
                (2 * Cn / En)^{1/((weight/2) - 1)}.
  */
  power := 1/((weight/2) - 1);
  lastCoeff := Floor( (2 * Cn / En)^power );
  return lastCoeff;
end function;


/*
      Input:
          f - The sequence of coefficients of a modular form.
          level - the level of the form.
          weight - the weight of the form.
          prec - the number of coefficients of f given.
      Output:
          1. Either true or false, depending on whether the algorithm was able to
             prove that f has all positive coefficients. (true if yes, false if no,
             or if there was insufficient data.)
          2. There are 3 possibilities for the second argument:
             a. 0 if there was insufficient data to determine if f has positive
                coefficients (this means that the Eisenstein part is either not
                strictly positive or only very narrowly positive in the long-run).
             b. If f is proven to not have all positive coefficients, a sequence
                of coefficients of f to sufficient precision to contain a negative
                value.
             c. If f is proved to have all positive coefficients, a sequence of 
                coefficients of f to sufficient precision to prove that all of
                the coefficients are f are positive (in conjuction with Deligne
                bounds and formulas for Eisenstein series.)
      Assumptions:
          All Eisenstein series at level and weight have rational coefficients.
          f has real coefficients.
          Any other inherited assumptions.
*/
FullPositivityCheck := function(f, level, weight, prec)
  newBasis, blah, fieldOfDef := DumbGetNewformBasis(level, weight, prec);
  bCoords, eCoords := GetSplitCoordsInBasis(newBasis, f, level, weight, prec, fieldOfDef);
  En := EisensteinLowerBound(eCoords, level, weight);
  Cn := CuspUpperBound(bCoords);
  print "Eisenstein Lower Bound is ___ * sigma_{k-1}(n) > ___ * n^(k-1)";
  En * 1.0;
  print "Cuspidal Bound is ___ * n^(k/2)";
  Cn * 1.0;

  /*
      At this point, if An is the coefficient of n, the triangle inequality 
      implies that:
                An >= En * n^{k-1} - 2 * Cn * n^{k/2}.
      The right-hand side is positive when 
                n^{(weight/2) - 1} >= 2 * Cn / En.
      So, to confirm positivity, it will suffice to check coefficients up to
                (2 * Cn / En)^{1/((weight/2) - 1)}.
      Might as well stop if we can't even show En is positive...
  */
  if En le 0 then
    "Unlikely to be positive - check Eisenstein part";
    return false, 0;
  end if;

  power := 1/((weight/2) - 1);

  // We should be able to compute this, since Cn/En is positive now. 
  lastCoeff := Floor( (2 * Cn / En)^power );

  // Declare that we're doing ok so far.
  "Checking up to coefficient " cat IntegerToString(lastCoeff);

  // q-expansions are 0-indexed.
  prec := lastCoeff + 1;

  /*
      The following code computes the form to the necessary precision.
      We already have the coordinates in terms of the new/oldform basis,
      so we use that. It would probably be better to use the default Magma
      basis, since I think it typically has a smaller coefficient field
      and the savings on field are probably worth an extra linear algebra 
      computation and easier computation of elements. This code probably exists
      in getBases.magma too...

      Step 1: Find the coordinates of the form in terms of a basis for the
              space of modular forms - linear algebra.
      Step 2: Extend the basis elements to the desired precision.
      Step 3: Use coordinates to get our form extended to the desired precision.
  */
  newBasis := DumbGetNewformBasis(level, weight, prec);
  CoeffList := [];
  for b in newBasis do
    CoeffList cat:= b;
  end for;
  //#CoeffList;
  dim := #bCoords + #eCoords;
  CoeffMx := Transpose(Matrix(dim, prec, CoeffList));
  CoordMx := Matrix(dim, 1, bCoords cat eCoords);
  /*
      As a terrible hack to get around the fact that Magma didn't want to
      allow coercion from BaseRing(CoeffMx) to BaseRing(CoordMx) or to just
      multiply, even though it should know they are the same ring, we can 
      change both rings to the compositum of the base fields so we can multiply.
  */
  TerribleHack := Compositum(BaseRing(CoeffMx), BaseRing(CoordMx));
  CoeffMx := ChangeRing(CoeffMx, TerribleHack);
  CoordMx := ChangeRing(CoordMx, TerribleHack);
  //Seriously, there must be a less ridiculous way to do this...
  Certificate := CoeffMx * CoordMx;

  /*
       Now, we check that all of the coefficients of our form are non-negative
       rational numbers like they should be. This might be suceptible to Magma
       being fussy about typecasting, but it seems to work. Remember that we
       have already checked all of the coefficients with large index.
  */
  for i in [1..prec] do
    if Rationals()!Certificate[i][1] lt 0 then
      "Coefficient " cat IntegerToString(i) cat " is negative.";
      return false, Certificate;
    end if;
  end for;
  "The given modular form has all nonnegative coefficients.";
  return true, Certificate;
end function;


/*
      Input:
          filename - A file containing the sequence of coefficients of 
                     a modular form.
          level - the level of the form.
          weight - the weight of the form.
          prec - the number of coefficients of f given.
      Output:
          1. Either true or false, depending on whether the algorithm was able to
             prove that f has all positive coefficients. (true if yes, false if no,
             or if there was insufficient data.)
          2. There are 3 possibilities for the second argument:
             a. 0 if there was insufficient data to determine if f has positive
                coefficients (this means that the Eisenstein part is either not
                strictly positive or only very narrowly positive in the long-run).
             b. If f is proven to not have all positive coefficients, a sequence
                of coefficients of f to sufficient precision to contain a negative
                value.
             c. If f is proved to have all positive coefficients, a sequence of 
                coefficients of f to sufficient precision to prove that all of
                the coefficients are f are positive (in conjuction with Deligne
                bounds and formulas for Eisenstein series.)
      Assumptions:
          All Eisenstein series at level and weight have rational coefficients.
          f has real coefficients.
          Any other inherited assumptions.
*/
FullPositivityCheckFromFile := function(filename, level, weight, prec)
  f := eval(Read(filename));
  foo,bar := FullPositivityCheck(f,level,weight,prec);
  return foo, bar;
end function;

/*
      Input:
          level - the level of the form.
          weight - the weight of the form.
          prec - the number of coefficients of f given.
          fnz - the first non-zero value of the form to test.
          (relevant forms exist following our naming conventions and
             file system structure, form and Atkin-Lehner dual.)
      Output:
          1. Either true or false, depending on whether the algorithm was able to
             prove that f has all positive coefficients. (true if yes, false if no,
             or if there was insufficient data.)
          2. There are 3 possibilities for the second argument:
             a. 0 if there was insufficient data to determine if f has positive
                coefficients (this means that the Eisenstein part is either not
                strictly positive or only very narrowly positive in the long-run).
             b. If f is proven to not have all positive coefficients, a sequence
                of coefficients of f to sufficient precision to contain a negative
                value.
             c. If f is proved to have all positive coefficients, a sequence of 
                coefficients of f to sufficient precision to prove that all of
                the coefficients are f are positive (in conjuction with Deligne
                bounds and formulas for Eisenstein series.)
      Assumptions:
          All Eisenstein series at level and weight have rational coefficients.
          f has real coefficients.
          Any other inherited assumptions.
*/
FullPositivityCheckOriginalAndDual := function(level, weight, prec, fnz)
  filename := "OptimalForms/Exact/" cat getFileName(level,weight,prec) cat "Z";
  filename cat:= IntegerToString(fnz);
  filenameDual := filename cat "Dual.txt";
  filename cat:= ".txt";
  foo:=FullPositivityCheckFromFile(filename,level,weight,prec);
  bar:=FullPositivityCheckFromFile(filenameDual,level,weight,prec);
  return foo and bar, foo, bar;
end function;  
  


// GetCuspidalNewformBasis(4,8,50);
/* 
   Example of how to compute the coordinates in terms of the
   newform basis, which is much more convenient for giving 
   tight bounds.
*/
/*
level := 24;
weight := 8;
prec := 100;
fnz := 6;

FullPositivityCheckOriginalAndDual(level, weight, prec, fnz);

C := CuspForms(level, weight);
SetPrecision(C,prec);
basis := Basis(C);
fSeq := [getCoefficientsToPrecision(qExpansion(b,prec),prec) : b in basis];

newBasis := GetNewformBasis(level, weight,prec);
V := VectorSpace(Rationals(), prec);
W := VectorSpaceWithBasis([V!v : v in newBasis]);

//transitionSeq := [Coordinates(W, V!f) : f in fSeq];
*/




