QQ := RationalField();
P<q> := PowerSeriesRing(QQ);
ZZ := IntegerRing();
R<q> := PowerSeriesRing(ZZ);


getFileName := function(level, weight, prec)
  fileName := "L";
  fileName cat:= IntegerToString(level);
  fileName cat:= "W";
  fileName cat:= IntegerToString(weight);
  fileName cat:= "P";
  fileName cat:= IntegerToString(prec);
  return fileName;
end function;

/*
  Returns the coefficients of the q-expansion at infinity padded
  to the full precision of the q-expansion.
*/
getCoefficientsToPrecision := function(series, precision)
  Coeffs, startpadding, d := Coefficients(series);
  Coeffs := [ 0 : x in [1..startpadding] ] cat Coeffs;
  endpadding := AbsolutePrecision(series) - ( #Coeffs );
  Coeffs cat:= [ 0 : x in [1..endpadding] ];
  //Coeffs;
  return Coeffs;
end function;

/* Given the sequence [a0, a1, ...], returns a sequence of the
   same length [a_0, 0, ..., 0, a_1, ...] such that each run 
   contains (expansionFactor - 1) zeros. */
ExpandAtPrecision := function(sequence, expansionFactor, weight)
  prec := # sequence;
  holder := [Rationals() | 0 : x in [1..prec]];
  j := 1;
  while expansionFactor * (j - 1) + 1 le prec do
    holder[expansionFactor * (j - 1) + 1] := sequence[j];
    j +:= 1;
  end while;
  return holder;
end function; 

/* Given the sequence [a0, a1, ...], returns a sequence of the
   same length [a_0, 0, ..., 0, (expansionFactor)^((weight - 1)/2) a_1, ...] 
   such that each run contains (expansionFactor - 1) zeros. */
ExpandAtPrecision2 := function(sequence, expansionFactor, weight)
  prec := # sequence;
  multiplier := (expansionFactor)^((weight - 1)/2);
  holder := [RealField() | 0 : x in [1..prec]];
  j := 1;
  while expansionFactor * (j - 1) + 1 le prec do
    holder[expansionFactor * (j - 1) + 1] := RealField()!(sequence[j]) * multiplier;
    j +:= 1;
  end while;
  return holder;
end function; 

/* Given the sequence [a0, a1, ...], returns a sequence of the
   same length [a_0, 0, ..., 0, (expansionFactor)^((weight)/2) a_1, ...] 
   such that each run contains (expansionFactor - 1) zeros. */
ExpandAtPrecisionWeak := function(sequence, expansionFactor, weight)
  prec := # sequence;
  multiplier := (expansionFactor)^(Integers()!(weight/2));
  holder := [Rationals() | 0 : x in [1..prec]];
  j := 1;
  while expansionFactor * (j - 1) + 1 le prec do
    holder[expansionFactor * (j - 1) + 1] := (sequence[j]) * multiplier;
    j +:= 1;
  end while;
  return holder;
end function; 

/* Currently assumes rational coefficients. */
DumbGetCuspidalNewformBasis := function(level, weight, prec)
  basis := [];
  expansions := [];
  for d in Divisors(level) do
    C := CuspForms(d, weight);
    SetPrecision(C, prec);
    newforms := Newforms(C);
    if #newforms gt 0 then
      for fWrapped in newforms do
        f := qExpansion(fWrapped[1]);
        seq := getCoefficientsToPrecision(f, prec);
        for e in Divisors(Integers()!(level/d)) do
          Append(~basis, ExpandAtPrecisionWeak(seq, e, weight));
          Append(~expansions, e);
        end for;
      end for;
    end if;
  end for;
  return basis, expansions;
end function;

DumbGetNewformBasis := function(level, weight, prec)
  basis, cExpansions := DumbGetCuspidalNewformBasis(level, weight, prec); 
  M := ModularForms(level, weight);
  ESeries := EisensteinSeries(M);
  E := [P!qExpansion(e,prec): e in ESeries];
  basis2 := [getCoefficientsToPrecision(f,prec) : f in E];
  return basis cat basis2, cExpansions;
  /* Is there a good way to store the Eisenstein data (including the characters?) */
end function;

// Returns a basis as a sequence of sequences of coefficients.
GetNewformBasis := function(level, weight, prec: write := true)
  filename := "Bases/";
  filename cat:= getFileName(level,weight,prec);
  filenameExp := filename cat "NewCuspExpansions.txt";
  filename cat:= "New.txt";
  System("touch " cat filename);
  contents := Read(filename);
  System("touch " cat filenameExp);
  contentsExp := Read(filenameExp);

  if (contents eq "") or (contentsExp eq "") then
    basis, cExp := DumbGetNewformBasis(level, weight, prec);
    if write then
      System("rm " cat filename);
      System("rm " cat filenameExp);
      Write(filename, basis);
      Write(filenameExp, cExp);
    else
      if contents eq "" then
        System("rm " cat filename);
      end if;
      if contentsExp eq "" then
        System("rm " cat filenameExp);
      end if;
    end if;
  else
    basis := eval(contents);
    cExp := eval(contentsExp);
  end if;
  return basis, cExp;
end function;

/* 
  Assumes all Eisenstein series in play have real coefficients.
  Returns a value lb so that the coefficient of n of the Eisenstein 
  part is at least lb * n^(k-1), where k is the weight.
*/
EisensteinLowerBound := function(coords, level, weight)
  M := ModularForms(level, weight);
  ESeries := EisensteinSeries(M);
  lb := 0;
  for d in [1..level] do
    sum := 0;
    for e in [1..#coords] do
      t := EisensteinData(ESeries[e])[3];
      chi := EisensteinData(ESeries[e])[1];
      if d mod t eq 0 then
        if (chi(d) * coords[e]) gt 0 then 
          multiplier := (1/t)^(weight - 1);
        else
          multiplier := 0;
          Divs := Divisors(IntegerRing()!(d/t));
          for dv in Divs do
            multiplier +:= (dv/d)^(weight - 1);
          end for;
          //t;
        end if;
        sum +:= (EisensteinData(ESeries[e])[1](d) * coords[e]) * multiplier;
      end if;
    end for;
    if d eq 1 then 
      lb := sum;
    else
      lb := Minimum(lb, sum);
    end if;
    //sum;
  end for;
  return lb;
end function;

CuspUpperBound := function(coords)
  sum := 0;
  for x in coords do
    sum +:= Abs(x);
  end for;
  return sum;
end function;

// Takes the basis elements and f as sequences of coefficients.
GetFullCoordsInBasis := function(basis, f, level, weight, prec)
  V := VectorSpace(Rationals(), prec);
  W := VectorSpaceWithBasis([V!v : v in basis]);
  return Coordinates(W, V!f);
end function;

GetSplitCoordsInBasis := function(basis, f, level, weight, prec)
  coords := GetFullCoordsInBasis(basis, f, level, weight, prec);
  cDim := Dimension(CuspForms(level, weight));
  mDim := Dimension(ModularForms(level, weight));
  bCoords := coords[1..cDim];
  eCoords := coords[(cDim+1)..mDim];
  return bCoords, eCoords;
end function;

// f is a list of prec many coefficients of a power series of level and weight.
NumberOfCoefficientsForPositivityCheck := function(f, level, weight, prec)
  newBasis := GetNewformBasis(level, weight, prec);
  bCoords, eCoords := GetSplitCoordsInBasis(newBasis, f, level, weight, prec);
  En := EisensteinLowerBound(eCoords, level, weight);
  //RealField()!En;
  Cn := CuspUpperBound(bCoords);
  //RealField()!Cn;
  power := 1/((weight/2) - 1);
  lastCoeff := Floor( (2 * Cn / En)^power );
  return lastCoeff;
end function;

FullPositivityCheck := function(f, level, weight, prec)
  newBasis := GetNewformBasis(level, weight, prec);
  bCoords, eCoords := GetSplitCoordsInBasis(newBasis, f, level, weight, prec);
  En := EisensteinLowerBound(eCoords, level, weight);
  Cn := CuspUpperBound(bCoords);
  power := 1/((weight/2) - 1);
  lastCoeff := Floor( (2 * Cn / En)^power );
  if lastCoeff le 0 then
    "Unlikely to be positive - check Eisenstein part";
    return false, 0;
  end if;
  "Checking up to coefficient " cat IntegerToString(lastCoeff);
  prec := lastCoeff + 1;
  newBasis := GetNewformBasis(level, weight, prec);
  CoeffList := [];
  for b in newBasis do
    CoeffList cat:= b;
  end for;
  //#CoeffList;
  dim := #bCoords + #eCoords;
  CoeffMx := Transpose(Matrix(dim, prec, CoeffList));
  CoordMx := Matrix(dim, 1, bCoords cat eCoords);
  Certificate := CoeffMx * CoordMx;
  for i in [1..prec] do
    if Certificate[i][1] lt 0 then
      "Coefficient " cat IntegerToString(i) cat " is negative.";
      return false, Certificate;
    end if;
  end for;
  "The given modular form has all nonnegative coefficients.";
  return true, Certificate;
end function;

FullPositivityCheckFromFile := function(filename, level, weight, prec)
  f := eval(Read(filename));
  foo,bar := FullPositivityCheck(f,level,weight,prec);
  return foo, bar;
end function;


FullPositivityCheckOriginalAndDual := function(level, weight, prec, fnz)
  filename := "OptimalForms/Exact/" cat getFileName(level,weight,prec) cat "Z";
  filename cat:= IntegerToString(fnz);
  filenameDual := filename cat "Dual.txt";
  filename cat:= ".txt";
  foo:=FullPositivityCheckFromFile(filename,level,weight,prec);
  bar:=FullPositivityCheckFromFile(filenameDual,level,weight,prec);
  return foo and bar, foo, bar;
end function;  
  


// GetCuspidalNewformBasis(4,8,50);
/* 
   Example of how to compute the coordinates in terms of the
   newform basis, which is much more convenient for giving 
   tight bounds.
*/
/*
level := 24;
weight := 8;
prec := 100;
fnz := 6;

FullPositivityCheckOriginalAndDual(level, weight, prec, fnz);

C := CuspForms(level, weight);
SetPrecision(C,prec);
basis := Basis(C);
fSeq := [getCoefficientsToPrecision(qExpansion(b,prec),prec) : b in basis];

newBasis := GetNewformBasis(level, weight,prec);
V := VectorSpace(Rationals(), prec);
W := VectorSpaceWithBasis([V!v : v in newBasis]);

//transitionSeq := [Coordinates(W, V!f) : f in fSeq];
*/




